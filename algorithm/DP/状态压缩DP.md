# 状态压缩DP

> 对暴力搜索的递推形式
>
> 把每一个被搜索对象用二进制中的 1 表示，没有被搜索过的用二进制中的 0 表示
>
> 时间复杂度（ $n^22^n$）
>
> n 范围 1<= n <=20



```c++

for(int s=1;s<=(1<<n)-1;s++){ //对于每个状态进行暴力枚举
    
    for(int i=1;i<=n;i++){  //对每个个体进行一次遍历
        
        if(s&(1<<(i-1)==0)) continue; //如果当前状态没有选中 i 那么，无法进行状态转移
        
        for(int j=1;j<=n;j++){ //对每个个体的当前状态进行一次遍历，判断是否能进行状态转移
          
            if（s&(i<<(j-1)==0) continue; //同上面一样，只有当状态同时选中 i 和 j 才能进行状态转移
        
            f[j][s]=max(f[j][s],f[j][s-(1<<(i-1))]+a[i][j])    //状态转移方程
            
               //进行状态的更新, (s-1<<(i-1))是指 s 不选择 i 时的状态（之前已经储存）+ 当前选择 i 的状态
            
        }
    }
     
}
```

