## 线段树

> 把一个大区间平均的分成两个小区间，由这两个小区间来维护大区间的信息，这样子使得维护的时间复杂度控制在 $log{N}$ 

## 1. 线段树的结构体

> 通常由两个大部分组成，该点所覆盖的区间，所覆盖区间的答案（最大值，区间和……）、注意需要开4倍空间（下面是开 4 倍空间的证明：
>
> 1. 最后一层有 1个，n-1 层有 n-1个节点，那么需要多开2*（n-1）个节点放在最后一层。
>
>   2. k-1 层的树总共 有 $2^{k-1}-1$个节点，第 k 层有  $2^{k-1}$个节点。假设第 k 层 有 n-1节点，那么前面的 k-1 总共有 $2^{k-1}$个节点，也就是 n-1。因此前面的 k 层有 2（n-1）个节点，最后一层多开了2*（n-1）个节点
>
>   3. 所以最坏情况需要的空间准确来说是（2*（n-1）） * 2=4n-4，所以选择开 4倍空间
>
>      ）

```c++
struct T{
    int l,r; // 所掌管的区间
    int sum; //维护区间「答案」的各种信息
}tr[N*4] ;//开 4倍空间
```

## 2. 由子区间修改父区间

> 当进行初始化、修改、查询（懒标记下传）的时候，都会对父区间（更大的区间）产生影响。因此，需要对父区间进行修改

```c++
void pushup(int u){
    // 以区间和为例：
    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;
}
```



 ## 3.线段树的初始化

>  用一个递归函数把结构体中的数据初始化，需要传三个参数（当前节点的下标，控制的左边界，控制的有边界）(int u,int l,int r);

```c++
void build(int u,int l,int r){
    tr[u]={l,r,w[r]};//根据题目初始化相应的信息,放在最开始避免忘记初始化（血泪教训）
    if(l==r){return ; } 

    else {
        int mid =l+r >>1;
        build(u<<1,l,mid);
        build(u<<1|1,mid+1,r);
        pushup(u);   //每次对子区间初始化后，都需要修改相应的父区间
    }
}
```

## 4. 单点修改

> 由线段树堆的性质，可以直接递归访问到所覆盖的所有的区间，直接修改对应区间的 「答案」。

```c++
//三个参数：节点下标、修改的节点的位置，修改的值
void modify(int u,int x,int v){
    if(tr[u].l==tr[u].r) {tr[u].sum+=v;} //掌管的区间被修改区间全部包围，即查找到了最大的子区间,这里「答案」是区间和
    else {
        
        int mid=tr[u].l+tr[u].r >>1;
        if(x<=mid) modify(u<<1,x,v);// 判断该点在当前的区间的左儿子还是右儿子
        else  modify(u<<1|1,x,v);
   	//！！！
        pushup(u); //修改后注意要修改父区间
    }
    
}
```

## 5. 懒标记（区间修改）

> 含义：当前区间的「答案」已经修改过了，但是子区间的「答案」还未进行更新的操作。
>
> 思想：懒标记的思想是和区间查询一样，如果需要修改的区间已经被全部覆盖，那么不需要继续向下修改就可以得到答案。
>
> **作用范围**：1. 在**修改子区间**的时候，进行下传；
>
> ​					2. 在**查询子区间**的时候，进行下传；

```c++
// 下传函数，传入父亲节点的下标
	void pushdown(int u){
        T &root=tr[u],&l=tr[u<<1],&r=tr[u<<1|1];
        if(root.add){ //add 为懒标记
          l.add+=root.add,l.sum+=(l.r-l.r+1)*root.add //懒标记下传之后，对应的「答案」跟新
          r.add+=root.add,r.sum+=(r.r-r.l+1)*root.add
          root.add=0; //下传之后注意进行初始化
        }
    }

//需要传4个参数，（节点下标，修改的左边界，修改的右边界，修改的值）
	void modify(int u,int l,int r,int v){
       if(tr[u].l>l&&tr[u].r<=r) { //找到修改的区间
           tr[u].add+=v;
           tr[u].sum+=(ll)(tr[u].r-tr[u].l+1)*v; //修改队形的懒标记和「答案」
       } 
        else{
            pushdown(u) //在修改子区间之前，把懒标记下传
           int mid =tr[u].l+tr[u].r >>1;
            if(l<=mid)modify(u<<1,l,r,v);
            if(r>mid) modify(u<<1|1,l,r,v); //两个if实际上包括了三种情况：
            								//		全部在左-->第一个
            								//		全部在右-->第二个
            								//		一半左一半右--> 第一个和第二个同时生效
            //!!!!
            pushup(u)//所有对子区间的影响都需要传递给父区间
            
        }
        
    }
```

## 6. 区间查询

> 通过线段树直接向下查询，分三种情况
>
> 1. 完全在左
> 2. 完全在右
> 3. 一半在左，一半在右

```c++
// 传递三个参数（节点下标，查询左边界，查询右边界）	
ll query(int u,int l,int r){
        if(tr[u].l>=l&&tr[u].r<=r) {return tr[u].sum;}
        else {
            pushdown(u); //向下递归都需要下传懒标记,懒标记的作用之一就是在查询子区间的时候才更新
            int mid=tr[u].l+tr[u].r >>1;
            if(r<=mid)  return query(u<<1,l,r); 	//只在左区间
            else if(l>mid) return query(u<<1|1,l,r);//只在右区间
            else {
                return query(u<<1,l,r)+query(u<<1|1,l,r);//在两个区间之间
            }
        }
    }
```

## 7.全部代码

**以最大值为例：**

```c++

const int N=1e5+10;   
struct T{
        int l,r;
        int mx;
    	int add;
    }tr[N*4];
    void pushup(int u){
        tr[u].mx=max(tr[u<<1].mx,tr[u<<1|1].mx);
    }
    void build(int u,int l,int r){
        tr[u]={l,r,0,0};
        if(l==r) return ;
        int mid=l+r>> 1;
        build(u<<1,l,mid);
        build(u<<1|1,mid+1,r);
        pushup(u);
    }
	void pushdown(int u){//以区间和为例
        T &root=tr[u],&l=tr[u<<1],&r=tr[u<<1|1];
        if(root.add){ 
          l.add+=root.add,l.sum+=(l.r-l.r+1)*root.add //懒标记下传之后，对应的「答案」跟新
          r.add+=root.add,r.sum+=(r.r-r.l+1)*root.add
          root.add=0; //下传之后注意进行初始化
        }
    }
    void modify(int u,int k,int num){
        if(tr[u].l==tr[u].r) {
            tr[u].mx=num;
            return ;
        }
           //pushdown(u);
        int mid=tr[u].l+tr[u].r >>1;
        if(k<=mid) modify(u<<1,k,num);
        else modify(u<<1|1,k,num);
        pushup(u);
    }
    int query(int u,int l,int r){
        if(tr[u].l>=l&&tr[u].r<=r) {
            return tr[u].mx;
        }
        //pushdown(u);
        int mid =tr[u].l+tr[u].r >>1;
        if(r<=mid) return query(u<<1,l,r);
        else if(l>mid) return query(u<<1|1,l,r);
        else return max(query(u<<1,l,r),query(u<<1|1,l,r));

    }
```

## 8.扫描线

![扫描线](https://oi-wiki.org/geometry/images/scanning.svg)

这里我们使用的是**从左到右**的扫描线

**1. 不需要pushdown**

> 因为两条边都是成对出现的，且+1在前 ，-1在后，所以一定可以知道，某个区域一定先被覆盖，然后才会被减去。

 综上可知，

1. 当父区间被完全覆盖的时候，**再次被覆盖**是不需要下传就能知道长度的
2. 当父节点没有被完全覆盖时，也不需要下传到子区间（没有意义）

**2. 不需要query**

> 查询的区间肯定是整个区间（根节点），所以不需要查询

**3. 离散化**

> 纵坐标的节点的个数太多了，需要用离散化来存储，同时考虑到当前是按照线段来存储的，所以需要把此时的节点的左右范围设置为$L …… R-1$

```c+++
 1. 排序+去重
 sort(ye.begin(),ye.end());
 ye.erase( unique(ye.begin(),ye.end()),ye.end());
 2. 找下标
  int  find(int num){
         return lower_bound(ye.begin(),ye.end(),num)-ye.begin(); //离散化后对应值的下标
   }
 3. pushup的时候需要对右边界+1
   if(tr[u].cnt){tr[u].len=ye[tr[u].r+1]-ye[tr[u].l];}
 4. modify的时候需要注意不是对整个区间 L……R ，而是L……R-1
  modify(1,find(segs[i].y1),find(segs[i].y2)-1,segs[i].k);
 
```



**4. 特殊处理pushup**

```c++
    void pushup(int u){
        //如果被完全覆盖，说明当前的长度就是（tr[u].l在ye中下标对应的值），
         if(tr[u].cnt){tr[u].len=ye[tr[u].r+1]-ye[tr[u].l];}//r需要加1，是因为这里的r都是减了1 的
         else if(tr[u].l==tr[u].r) tr[u].len=0;//表示的是线段，因此这里长度为0
         else {
             tr[u].len=tr[u<<1].len+tr[u<<1|1].len;
         }
     }
```



```c++
const int N=1e5+10;
const int mod=1e9+7;
class Solution {
public:
    struct seg{
       int x,y1,y2; 
       int k;
       bool operator <(const seg& t)const {
            return x<t.x;
        }
    }segs[N*2];
    struct T{
        int l,r;
        int cnt; //该区域被完全覆盖的次数
        long long len;//该区域的长度
    }tr[N*2*4];
     vector <int> ye;
     int  find(int num){
         return lower_bound(ye.begin(),ye.end(),num)-ye.begin(); //离散化后对应值的下标
     }
     void pushup(int u){
        //如果被完全覆盖，说明当前的长度就是（tr[u].l在ye中下标对应的值），
         if(tr[u].cnt){tr[u].len=ye[tr[u].r+1]-ye[tr[u].l];}//r需要加1，是因为这里的r都是减了1 的
         else if(tr[u].l==tr[u].r) tr[u].len=0;//表示的是线段，因此这里长度为0
         else {
             tr[u].len=tr[u<<1].len+tr[u<<1|1].len;
         }
     }
     void build(int u,int l,int r){
         tr[u]={l,r,0,0};
         if(l==r) return ;
         int mid=l+r >>1;
         build(u<<1,l,mid);
         build(u<<1|1,mid+1,r);
         //不需要pushup，因为不会进行任何操作
     }
     void modify(int u,int l,int r,int k){
         if(tr[u].l>=l&&tr[u].r<=r) {
             tr[u].cnt+=k;
             pushup(u);
         }
         else {
             int mid=tr[u].l+tr[u].r>>1;
             if(l<=mid) modify(u<<1,l,r,k);
             if(r>mid) modify(u<<1|1,l,r,k);
             pushup(u); 
         }

     }

    int rectangleArea(vector<vector<int>>& rectangles) {
        int n=rectangles.size();
        ye.clear();
        for(int i=0,num=0;i<n;i++){
             vector<int> v;   
            for(int j=0;j<4;j++){
                v.push_back(rectangles[i][j]);
            }
            segs[num++]={v[0],v[1],v[3],1};
            segs[num++]={v[2],v[1],v[3],-1};
             ye.push_back(v[1]);
             ye.push_back(v[3]);   
        }
        build(1,0,ye.size()-2);//一个点表示一个线段，因此只有m-1个线段
        sort(ye.begin(),ye.end());
        ye.erase( unique(ye.begin(),ye.end()),ye.end());
        sort(segs,segs+n*2);
        long long ans=0;
        for(int i=0;i<n*2;i++){
           if(i>0) ans=(ans+tr[1].len*(segs[i].x-segs[i-1].x))%mod;

                // 一个点表示的是一个线段，所以要-1
            modify(1,find(segs[i].y1),find(segs[i].y2)-1,segs[i].k);
        }
        return ans;
    }
    
};
```

