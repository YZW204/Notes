## 线段树

> 把一个大区间平均的分成两个小区间，由这两个小区间来维护大区间的信息，这样子使得维护的时间复杂度控制在 $log{N}$ 

## 1. 线段树的结构体

> 通常由两个大部分组成，该点所覆盖的区间，所覆盖区间的答案（最大值，区间和……）、注意需要开4倍空间（下面是开 4 倍空间的证明：
>
> 1. 最后一层有 1个，n-1 层有 n-1个节点，那么需要多开2*（n-1）个节点放在最后一层。
>
>   2. k-1 层的树总共 有 $2^{k-1}-1$个节点，第 k 层有  $2^{k-1}$个节点。假设第 k 层 有 n-1节点，那么前面的 k-1 总共有 $2^{k-1}$个节点，也就是 n-1。因此前面的 k 层有 2（n-1）个节点，最后一层多开了2*（n-1）个节点
>
>   3. 所以最坏情况需要的空间准确来说是（2*（n-1）） * 2=4n-4，所以选择开 4倍空间
>
>      ）

```c++
struct T{
    int l,r; // 所掌管的区间
    int sum; //维护区间「答案」的各种信息
}tr[N*4] //开 4倍空间
```

## 2. 由子区间修改父区间

> 当进行初始化、修改、查询（懒标记下传）的时候，都会对父区间（更大的区间）产生影响。因此，需要对父区间进行修改

```c++
void pushup(int u){
    // 以区间和为例：
    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;
}
```



 ## 3.线段树的初始化

>  用一个递归函数把结构体中的数据初始化，需要传三个参数（当前节点的下标，控制的左边界，控制的有边界）(int u,int l,int r);

```c++
void build(int u,int l,int r){
    tr[u]={l,r,w[r]};//根据题目初始化相应的信息,放在最开始避免忘记初始化（血泪教训）
    if(l==r){return ; } 

    else {
        int mid =l+r >>1;
        build(u<<1,l,mid);
        build(u<<1|1.mid+1,r);
        pushup(u);   //每次对子区间初始化后，都需要修改相应的父区间
    }
}
```

## 4. 单点修改

> 由线段树堆的性质，可以直接递归访问到所覆盖的所有的区间，直接修改对应区间的 「答案」。

```c++
//三个参数：节点下标、修改的节点的位置，修改的值
void modify(int u,int x,int v){
    if(tr[u].l==tr[u].r) {tr[u].sum+=v;} //掌管的区间被修改区间全部包围，即查找到了最大的子区间,这里「答案」是区间和
    else {
        
        int mid=tr[u].l+tr[u].r >>1;
        if(x<=mid) modify(u<<1,x,v);// 判断该点在当前的区间的左儿子还是右儿子
        else  modify(u<<1|1,x,v);
   	//！！！
        pushup(u); //修改后注意要修改父区间
    }
    
}
```

## 5. 懒标记（区间修改）

> 含义：当前区间的「答案」已经修改过了，但是子区间的「答案」还未进行更新的操作。
>
> 思想：懒标记的思想是和区间查询一样，如果需要修改的区间已经被全部覆盖，那么不需要继续向下修改就可以得到答案。
>
> 作用范围：1. 在修改子区间的时候，进行下传；
>
> ​					2. 在查询子区间的时候，进行下传；

```c++
// 下传函数，传入父亲节点的下标
	void pushdown(int u){
        T &root=tr[u],&l=tr[u<<1],&r=tr[u<<1|1];
        if(root.add){ //add 为懒标记
          l.add+=root.add,l.sum+=(l.r-l.r+1)*root.add //懒标记下传之后，对应的「答案」跟新
          r.add+=root.add,r.sum+=(r.r-r.l+1)*root.add
          root.add=0; //下传之后注意进行初始化
        }
    }

//需要传4个参数，（节点下标，修改的左边界，修改的右边界，修改的值）
	void modify(int u,int l,int r,int v){
       if(tr[u].l>l&&tr[u].r<=r) { //找到修改的区间
           tr[u].add+=v;
           tr[u].sum+=(ll)(tr[u].r-tr[u].l+1)*v; //修改队形的懒标记和「答案」
       } 
        else{
            pushdown(u) //在修改子区间之前，把懒标记下传
           int mid =tr[u].l+tr[u].r >>1;
            if(l<=mid)modify(u<<1,l,r,v);
            if(r>mid) modify(u<<1|1,l,r,v); //两个if实际上包括了三种情况：
            								//		全部在左-->第一个
            								//		全部在右-->第二个
            								//		一半左一半右--> 第一个和第二个同时生效
            //!!!!
            pushup(u)//所有对子区间的影响都需要传递给父区间
            
        }
        
    }
```

## 6. 区间查询

> 通过线段树直接向下查询，分三种情况
>
> 1. 完全在左
> 2. 完全在右
> 3. 一半在左，一半在右

```c++
// 传递三个参数（节点下标，查询左边界，查询右边界）	
ll query(int u,int l,int r){
        if(tr[u].l>=l&&tr[u].r<=r) {return tr[u].sum;}
        else {
            pushdown(u); //向下递归都需要下传懒标记,懒标记的作用之一就是在查询子区间的时候才更新
            int mid=tr[u].l+tr[u].r >>1;
            if(r<=mid)  return query(u<<1,l,r); 	//只在左区间
            else if(l>mid) return quert(u<<1|1,l,r);//只在右区间
            else {
                return query(u<<1,l,r)+query(u<<1,l,r);//在两个区间之间
            }
        }
    }
```

