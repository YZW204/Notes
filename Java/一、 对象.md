# 一、 对象

常量：在堆中直接存放

引用：堆中存放地址，在方法区中存放地址对应的值

![image-20230222210550159](C:\Users\17848\AppData\Roaming\Typora\typora-user-images\image-20230222210550159.png)

> p2=p1是把地址赋值给p1
>
>
> Java 内存的结构分析
> 1) 栈： 一般存放基本数据类型(局部变量)
> 2) 堆： 存放对象(Cat cat , 数组等)
> 3) 方法区：常量池(常量，比如字符串)， 类加载信息

### 1. **方法**

> 执行方法的时候会调用一些栈空间生成一个方法运行的栈空间来运行，运行结束后会销毁这个空间

![image-20230222212145973](C:\Users\17848\AppData\Roaming\Typora\typora-user-images\image-20230222212145973.png)

### 2. 可变参数

在函数传参的时候可以用`类型 ... 变量名`来表示可变参数

如：

```java
int sum(int ...num){
    
}
```

- 实质为数组，使用的时候可以用数组的函数。如：num.length
- 只能有一个可变参数
- 必须放在最后

### 3. 对象形成的流程

1. 加载类信息，只会加载一次
2. 在堆中分配空间（地址）
3. 完成对象的初始化
   1. 默认初始化	0/null
   2. 显示初始化     name=10
   3. 构造器初始化 
4. 在对象堆中的地址返回给对象名

### 4. this

> 相当于一个指向自己的指针

![image-20230223193252335](C:\Users\17848\AppData\Roaming\Typora\typora-user-images\image-20230223193252335.png)

- 注意：

1. 可以用来访问类的属性、方法、构造器
2. 用来区分当前属性类的属性和变量
3. 访问成员的方法：this.方法名
4. 访问构造器：只能在构造器的第一句这个位置使用this（参数列表）
5. 只能在类中使用

### 5. 包

> 实际上就是创建不同的文件夹来保存类文件

三大作用：

1. 区分名字相同的类
2. 当类很多时，可以很好的管理类
3. 控制访问的范围

### 6. 封装

> 数据被保护在内部，只有通过被授权的方法才能进行操作

- 步骤：

1. 属性私有化[不能直接修改属性]
2. 提供一个公共的方法来修改属性
3. 提供一个公共的方法来获取属性

### 7. 继承

> 解决了代码复用的问题，代码的扩展性和维护性提高

1. 子类继承了父类的所有属性和方法，公共的属性和方法可以直接访问，但是不能直接访问父类的私有属性，要通过父类提供的方法来访问
2. 子类必须调用父类的无参构造器，完成父类的初始化
3. 创建子类对象的时候，默认会调用父类的无参构造器；如果父类没有无参构造器（被覆盖），则必须在子类中用super去指定使用父类的构造器来完成父类的初始化
4. 如果想指定使用某个父类的构造器，则显示地使用super调用一下
5. super在使用时，需要放在构造器的第一行
6. super() 和this() 只能在构造器的第一行，并且不能共存在构造器中
7. java类都是Object的子类
8. 父类构造器的调用不限于直接父类，将一直往上追溯到Object类（顶级父类）
9. 子类最多只能继承一个父类（直接继承），单继承机制
10. 不能滥用继承关系，需要满足基本的逻辑关系

- 内存布局

![image-20230224130010550](C:\Users\17848\AppData\Roaming\Typora\typora-user-images\image-20230224130010550.png)

> 会从顶级的父类开始在先在堆中为父类们的属性赋值，最后才是自己的属性

### 8. super

> 用来访问父类的的属性，方法，构造器；但是不能访问**private**的属性和方法

- 直接使用属性和方法(不加super)，会从当前的子类开始，往上查找是否有该属性和方法
- super.属性，就是从父类开始查找相关的属性和方法

**好处和细节：**

1. 调用父类构造器的好处：分工明确，父类属性由父类初始化，子类属性由子类初始化
2. 当访问和子类重名的属性和方法时，要用super

**对比this**

![image-20230224132357840](C:\Users\17848\AppData\Roaming\Typora\typora-user-images\image-20230224132357840.png)



**重写：**

> 子类的权限不能小于父类，但是可以大于父类

### 9. 多态

1. 方法的多态：

   重写（子类重写父类），重载（同名，不同参）体现多态

2. 对象的多态：

   1. 对象的编译类型和运行类型可以不一致
   2. 编译类型在定义对象的时候就确定了，不能改变
   3. 运行类型是可以改变的

3. 多态细节

   - **向上转型**

     > 本质：是父类的引用指向了子类的对象
     >
     > 语法：父类类型 引用名 =	new	子类类型()

   1. 只能调用父类的属性和方法（遵守访问权限），不能调用子类特有的
   2. 运行时看子类的具体实现效果

   - **向下转型**

     > 本质：指向了子类的父类引用，转换成子类引用
     >
     > 语法：子类类型 引用名 = (子类类型) 父类引用

   1. 只能强制转换父类的引用，不能强制转换父类的对象
   2. 父类的引用必须是指向当前转换的对象
   3. 转型后，可以调用子类的特有属性和方法

   - **属性没有重写之说**

     >  属性的值看编译类型

   - instanceof 

     > 判断对象的**运行类型**是否是后面对象的类型或者子类型

   - **动态绑定机制**

     1. 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型进行绑定
     2. 调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

   - **多态数组**

     > 数组的定义类型为父类型，里面实际上保存的是子元素

     需要用到子元素特有的方法时，就可以使用向下转型然后调用方法

# 二、Object

## == 和equals

- ==

1. 既可以判断基本数据类型，又可以判断引用数据类型
2. 判断基本数据类型时，判断值是否相等
3. 判断引用数据类型时，判断地址是否相等

- equals

1. 默认只能判断地址是否相等
2. 如果是Integer和String，因为经过重写，所以会判断值是否相等



## finalize

1. 当对象被回收的时候，系统会调用这个方法。子类可以进行重写，增加一些操作
2. 当对象没有被引用的时候，jvm会认为这是一个垃圾对象，会使用垃圾回收机制来销毁对象，销毁前会调用finalize算法
3. 垃圾回收机制的调用，最终由系统来决定



# 三、高级部分编程

## 1. 类变量static

> 类变量是在类加载的时候就生成了。

注意：

1. static变量是同一个类所有对象共享
2. static类变量，在类加载的时候就生成了
3. 因为是在类加载的时候就生成了，所以没有对象实例也是可以直接通过类访问
4. 类变量推荐使用类.类变量访问
5. 类变量的生命周期是随着类的加载开始，随着类的消亡而消亡



类方法的意义：

> 当方法不涉及任何和对象相关的成员时，可以将方法设置成静态方法，提高效率。比如许多的工具类都是静态方法，不需要额外的 new 一个对象，可以直接通过**类名.方法**直接使用

类方法的注意事项：

> 首先明确一点，类方法，类变量都是随着类的加载而加载的，是在对象创建前就已经加载完成了，以下注意事项都可以由这个顺序来理解

1. 类方法和变量都是随着类的加载而加载的，将结构信息存储在方法区，（由于还没有对象）类方法中没有this 参数，（对象已经创建）普通方法隐藏this 参数
2. 类方法可以通过类名和对象直接调用
3. 普通方法与对象有关，只能由对象调用，不能由类名调用
4. 类方法中不允许使用和对象有关的关键字，比如：this 和 super （因为对象还没创建），普通方法可以（对象已经创建）
5. 类方法只能访问静态变量和静态方法（对象未创建，只加载了静态变量和静态方法）
6. 普通成员方法既可以方法静态变量，也可以访问静态方法（类已经加载，对象也已经创建）

## 2. main

> public static void main(String args[])

1. main方法是被虚拟机调用，为了可以直接调用，所以使用static
2. 访问权限需要是public ，虚拟机才可以调用到main
3. String 是执行java命令时传参给main的参数数组
4. 同样遵守静态方法的所有规则

## 3. 代码块

> 属于类中的成员，是类的一部分，类似方法，将逻辑语句封装在方法体内	，通过{}包围起来
>
> 不同：
>
> 1. 没有方法名，没有返回值，没有参数，只有方法体，
>
> 2. 不能通过对象或类显示的调用
>
> 3. 只能在加载类或者创建对象的时候隐式的调用

- **语法**

```java
[修饰符]{
    
};
```

- 理解：

1. 是一种对构造器的补充
2. 重复语句可以抽取到初始化语句中，提高代码的复用性

- 注意事项和细节：

1. static代码块会随着类加载而调用（但是类只加载一次，所以只会调用一次），普通代码块会在创建对象的时候调用
2. 类什么时候被加载：
   1. 创建对象实例时new
   2. 创建子类对象实例，父类也会被加载，且父类是先被加载的
   3. 使用类的静态成员和属性时
3. 创建一个对象的调用顺序：
   1. 按顺序调用静态变量和静态属性
   2. 按顺序调用普通变量和普通属性
   3. 调用构造方法（构造方法是最后执行的）

**总的顺序：**

1. 父类静态
2. 子类静态
3. 父类普通
4. 父类构造
5. 子类普通
6. 子类构造



## 4. 单例设计模式

> 采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个公共方法来获取对象

- 饿汉式和懒汉式的步骤

1. 构造器私有化-----(防止其他外界生成对象)
2. 类内部创建对象
3. 向外暴露一个静态的公共方法----(返回该类的对象)

- 饿汉式特点：

直接在类加载的时候就创建了对象

```java
public static 对象 引用名 = new 对象()
```

- 懒汉式特点：

在调用获取对象的函数时才创建了对象

```java
public static 对象 getinstance (){
     public static 对象 引用名 = new 对象();
    
    return 对象;
}
```

**总的对比**

1. 创建对象时机不同：饿汉式在类加载的时候，懒汉式在获取对象的时候
2. 懒汉式存在线程问题
3. 饿汉式存在浪费空间的问题



## 5. final

> 可以修饰类、属性、方法和局部变量

使用情况：

1. 不希望类被继承
2. 不希望方法被重写
3. 不希望属性被修改



细节：

1. final修饰的属性又叫**常量**，一般用大写字母来命名

2. final 修饰属性时，必须赋值，可以在以下地方赋值：

   1. 在定义的时候
   2. 在构造器中；如果是静态的变量则不能在构造器中赋值
   3. 在代码块中

3. final 不能修饰构造方法

4. final 和static 搭配使用，不会导致类加载，效率更高（底层有优化）

   调用属性的时候不会加载类



**补充：**

​		final修饰一个基本数据类型时，表示该**基本数据类型的值一旦在初始化后便不能发生变化**；如果final修饰一个引用类型时，**则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的**。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。



## 6. 抽象类

> 父类有一部分方法不确定，但是子类又一定会使用的方法的方法，可以讲父类设置成抽象类



介绍：

1. 用abstract 修饰类或方法，这个类或方法就叫做抽象类/抽象方法(方法没有方法体)
2. 抽象类的价值在于设计，设计者设计好后，让子类继承并实现

细节：

1. 抽象类不能被实例化。
2. 抽象类可以不包括abstract 方法，可以包括其他的方法
3. abstract 只能修饰方法和类，不能修饰属性
4. 抽象类本质还是类，可以拥有任何成员
5. 如果一个类继承了抽象类，那么他必须是重写抽象方法，或者他自己也是一个抽象类
6. 抽象方法不能用private、final 、static 来修饰，因为他们都与重写相违背

**模板设计模式**

> 抽象类作为子类的通用模板，子类会扩展抽象类

当一部分问题是确定的，一部分问题又是不确定，就可以把这部分问题暴露出去，让子类来实现



## 7. 接口

> 给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据情况把方法实现

语法：

```java
声明：
interface 接口名{
    属性
    方法
}

继承接口：
    
 class 类名 implement 接口{
     自己的属性
         方法
     必须实现的接口的方法
     jdk8之后可以有其他方法（静态方法，默认方法）
 }
```

接口是更加抽象的抽象类

**注意事项：**

1. 接口不能被实例
2. 接口中的方法都是 public ，接口中的抽象方法是默认的，可以不能声明
3. 普通类继承接口，必须实现接口的所有方法，抽象类可以不用实现
4. **一个类可以同时实现多个接口**
5. 接口中的属性默认并且只会是 public static final
6. 接口中的属性访问，接口名.属性名或者实现的对象.属性
7. 接口不能继承类，但是可以继承多个其他接口
8. 接口的修饰符只能是public 和默认的

**接口相同的特性**

1. 多态参数，接口可以指向所以实现了接口的类
2. 多态数组，接口数组可以存放所有的视线了接口的类
3. 接口存在**多态传递现象**，继承的类也可以被接口指向

## 8. 内部类

> 一个类的内部嵌套了另一个类

**类别**

1. 定义在外部类的局部位置上（方法上）
   1. 局部内部类（有类名）
   2. 匿名内部类（没有类名）
2. 定义在外部类的成员位置上：
   1. 成员内部类（没有static 修饰）
   2. 静态内部类（使用static 修饰）





### 局部内部类

> 定义在方法（代码块）中

1. 可以直接访问外部类的所有成员，包括私有

2. 不能添加修饰符，但是可以添加final

3. 作用域：他所在的代码块和方法内

4. 局部内部类可以直接访问外部类的成员

   外部类访问内部类成员，先创建对象，在根据权限规则访问

5. 外部类不能访问局部内部类，因为局部内部类本质也是一个局部变量

6. 外部类和局部内部类成员变量重名时，遵守就近原则。如果想访问外部类的成员，可以使用（外部类名.this.成员）进行访问





### 匿名内部类

> 定义在方法（代码块）中

**语法：**

```java
new 类名或者接口 (参数列表){
    类体
};
1. 本质还是一个类
2. 内部类
3. 没有名字
4. 同时还是一个对象
```

**特性**：

1. 既是一个类的定义，同时它本身又是一个对象
2. 可以直接访问外部的所有成员
3. 不能添加访问修饰符，因为它本身就是一个局部变量
4. 作用域：在他的代码块或方法体中
5. 外部类不能访问匿名内部类（它只是一个局部变量，并且没有名字）
6. 外部变量和内部变量重名的话，遵守就近原则，此时想要访问外部变量使用`外部类名.this.变量`
7. 匿名内部类可以直接当做参数进行传递，同时重写一些方法





### 成员内部类

> 成员内部类是定义在成员位置的类

**特性：**

1. 可以直接访问外部类的所有成员
2. 可以添加任意修饰符（public、protected……），因为他是一个成员
3. 作用域：整个类体
4. 访问的方式：
   1. 内部类访问外部类成员------（直接访问）
   2. **外部类/外部其他类**  访问内部类成员-----（先创建对象再访问成员）
   3. 外部类和内部类成员重名时，遵守就近原则，此时想要访问外部类成员使用`外部类名.this.变量`

### 静态内部类

> 定义在成员位置的类，有static修饰

1. 可以直接访问外部类的所有**静态**成员
2. 可以添加任意修饰符（public、protected……），因为他是一个成员
3. 作用域：整个类体
4. 访问的方式：
   1. 内部类访问外部类**静态**成员------（直接访问）
   2. **外部类/外部其他类**  访问内部类成员-----（先创建对象再访问成员）
   3. 外部类和内部类成员重名时，遵守就近原则，此时想要访问外部类**静态**成员使用`外部类名.变量`

