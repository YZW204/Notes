# 二、实践

## 1. 枚举

> 自定义和使用enum关键字实现

**自定义枚举：**

**特性**

1. 不需要提供set方法，枚举对象通常为只读
2. 对枚举对象实现final 和static  共同修饰，实现底层优化
3. 枚举对象名通常全部大写，常量名规范



小结：

1. 构造器私有化，防止增加对象
2. 本类内部创建一组对象（枚举对象）
3. 对外暴露创建的枚举对象（使用关键字 public final static ）
4. 可以提供get方法，但是不能提供set 方法



**注意事项：**

1. 使用关键字enum时，会默认继承Enum类，并且是final属性的
2. 传统创建对象`public static final Season2 SPRING = new Season2("春天", "温暖"); 简化成 SPRING("春天", "温暖"`,必须在枚举类中重写所使用的构造函数
3. 枚举的对象必须放在枚举类的首行

4. 继承的一些属性

   ```java
   1) toString:Enum 类已经重写过了，返回的是当前对象
   名,子类可以重写该方法，用于返回对象的属性信息
   2) name：返回当前对象名（常量名），子类中不能重写
   3) ordinal：返回当前对象的位置号，默认从 0 开始
   4) values：返回当前枚举类中所有的常量
   5) valueOf：将字符串转换成枚举对象，要求字符串必须
   为已有的常量名，否则报异常！
   6) compareTo：比较两个枚举常量，比较的就是编号！
   ```

5. 不能再继承其他类，因为他自己已经隐式的继承了Enum类

6. 但是他和普通的类一样，还是可以实现接口



## 2. 异常

> 程序中执行的不正常行为称为异常

分类：

1. 错误Error：jvm无法处理的错误，栈溢出
2. 异常Exception：编程错误或者是运行时的异常；
   1. 编译异常
   2. 运行时异常





- 常见的运行时异常

1. NullPointerException 空指针异常

2) ArithmeticException 数学运算异常
3) ArrayIndexOutOfBoundsException 数组下标越界异常
4) ClassCastException 类型转换异常
5) NumberFormatException 数字格式不正确异常[]





**异常处理方式：**

1. `try--catch--finally`		自行处理
2. `throws`    抛出异常，由调用者处理（最大的调用者是JVM）



**`try --catch异常`**

1. 可以有多个catch语句，但是要求子类异常在前，父类异常在后，如果发生异常，则只会匹配一个catch





`throws 异常`

> 如果发现异常，但是不知道如何处理，就抛出异常（抛给调用者），由调用者去处理异常

1. 编译异常必须处理，比如throws，或者try--catch
2. **运行时异常可以不用处理**，默认是throws（抛给JVM）
3. 子类重写父类的时候，必须也抛出**相同的异常，或者更小范围的异常**
4. 如果该方法被`try--catch`了，也可以不用throws





**自定义异常：**

> 当某些过程不符合程序的要求，也可以认为是“异常”，需要自己定义这种类型的异常

语法：

```java
自定义异常类名 extends Exception /RuntimeException
    Exception：编译异常
    RuntimeException：运行时异常（一般都是这个）
    

在需要抛出异常的地方：throw 这个继承了异常的对象
```

## 3. 包装类

> 把基本数据类型相对应的引用类型称为包装类

![image-20230228181951622](C:\Users\17848\AppData\Roaming\Typora\typora-user-images\image-20230228181951622.png)

**包装类和基本数据类型的基本转换**

> jkd5以前需要手动转换，现在是自动转换，也叫  **装箱、拆箱**，底层调用的是 valueOf 方法如：Integer.valueOf()

```java
//自动装箱 int->Integer
Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2)
//自动拆箱 Integer->int
int n3 = integer2; //底层仍然使用的是 intValue()方法

```

补充：

```java
Object obj =true?new Integer(1):new Double (2.0)
    System.out.println(obj)
    
    输出的结果是1.0，因为三元运算符是一个整体，所以类型是double类型
```





### **Integer类：**

`Integer a=new Integer(1)`,此时会直接返回一个对象，不会创建新的对象

```java
源码：
public static Integer valueOf(int i) {
	if (i >= IntegerCache.low && i <= IntegerCache.high)

		return IntegerCache.cache[i + (-IntegerCache.low)];

	return new Integer(i);
}
```

1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回
2. 如果不在 -128~127,就直接 new Integer(i)，会创建一个新的对象





### **String类：**

> 使用的字符编码是Unicode，占用两个字节

1. String 具有许多的构造器
2. String 是final类，不能被其他类继承
3. String 有私有属性，`public static char value[]`，用来存放字符串内容
   1.  value 是final 修饰，不能修改
   2. 但是value 的内容是可以修改的，只是不能指向新的内容







**创建String 对象**

1. 直接赋值`String s="yzw"`
   1. 如果常量池有这个字符串，则直接指向这个常量池
   2. 如果常量池没有这个字符串，则先创建一个String 对象和常量池的字符串，再指向这个字符串
2. 调用构造器`String  s=new String ("yzw");`
   1. 先创建String 对象然后指向常量池
   2. 如果常量池没有这个变量，则创建这个变量后再指向





**特性：**

1. String 是final 修饰的类，代表不可变的序列
2. 字符串是不可变的，一个字符串对象一旦被创建，其内容是不可变的（这个不变是说的是Sting 类的属性value是不可变的，他是一直保存在内存中的），因为value 是 final 修饰的。他是存储在常量池中的，可以被其他对象引用所共享，所以要求不可变。
3. 对象的引用是可以变的，因为对象的引用并没有被final 修饰，所以对象的引用可以指向其他地址，使得好像修改了值。
4. `String s="aa"+"bb"`这个过程只创建了一个对象，编译器会在常量池中优化成`String s="aabb"`
5. String 中的许多方法修改String 是通过new 一个新的String对象来实现的，所以在实际过程中会十分消耗时间



**StringBuffer**

> 和String差不多，但是字符串是可变长度



**特性：**

1.  StringBuffer 的直接父类 是 AbstractStringBuilder
2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化
3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final，所以内容是放在堆中的
4. StringBuffer 是一个 final 类，不能被继承
5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)；因此修改的时候不需要创建新的对象，所以他的修改效率更高



**和String 对比：**

1. String保存的是字符串常量，值是不能更改的，每次更改都是让引用指向新创建的对象，效率较低
2. StringBuffer 保存的是字符串变量，值更改不需要修改地址，效率更高



**StringBuffer 和 String 的转换：**

- String---> StingBuffer
  1. 使用构造器：`StringBuffer stringBuffer = new StringBuffer(str);`
  2. 使用的是 append 方法：`stringBuffer1 = stringBuffer1.append(str);`
- StringBuffer--->String
  1.  使用 StringBuffer 提供的 toString 方法	`String s = stringBuffer3.toString();`
  2. 使用构造器来搞定:  String s1 = new String(stringBuffer3);





**StringBuilder：**

> 是一个可变的字符串序列，与StringBuffer 兼容的API，不能保证同步。**主要用在字符串缓冲被单个线程使用的时候**





String 、StingBuffer 、StringBuilder：

1. StingBuffer 、StringBuilder都是可变字符序列，方法也相同
2. String：不可变序列，效率低，复用性高
3. StringBuffer：可变序列，效率高，线程安全
4. StringBuilder：可变序列，效率高，线程不安全







### Arrays

> Arrays类包含了一系列的静态方法，用于管理和操作数组（排序，搜索）

1. `Arrays.toString(String str)`返回数组的字符串形式
2. `Arrays.sort()`，自然排序和自定义排序（通过实现一个接口）
3. `binarySearch`通过二分搜索查找某个元素
4. `copyOf`复制数组给另一个数组
5. `fill`数组填充
6. `equals`比较两个数组是否完全一致
7. `alist`将数组转换成list





### System：

exit：退出当前程序

currentTimeMillens：返回距离1970-1-1的时间

`System.arraycopy(源数组,原数组拷贝的开始位置，目标数组，拷贝到目标的目的位置，拷贝多少个)`





### BigInteger和BigDecimal

> 处理较大的整数和浮点数

- 加减法都需要通过调用类的方法的进行

  `add 加；subtract 减；multiply乘；divide除 `







622

492p